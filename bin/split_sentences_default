#!/usr/bin/env perl

use strict;
use utf8;
use Encode;
use FindBin qw/$Bin/;
use lib "$Bin/../perllib/";
use FileHandle;
use CGI qw/:standard/;
use CGI::Carp qw(fatalsToBrowser);
use File::Temp 'tempdir';
use JSON;
use IO::File;

binmode STDIN, ":encoding(utf8)";
binmode STDOUT, ":encoding(utf8)";
binmode STDERR, ":encoding(utf8)";

STDOUT->autoflush(1);

my $response = '';
my $cgi = new CGI;

my $src = $cgi->param('text');
my $lang_source = $cgi->param('lang_source');
my $lang_target = $cgi->param('lang_target');

# HTTPヘッダ出力
$response = header(-Content_Type => 'application/json',
    -charset       => 'utf-8',
    -Pragma        => 'no-cache',
    -Cache_Control => 'no-cache');

$src = decode('utf8', $src);
$src =~ s/^\s*(.*?)\s*$/$1/; # 両端のスペース消去

die "no input!" if ($src eq "");

my $tmpdir = tempdir;

# 文に分割
my $temp_file = "$tmpdir/in";
open(my $fh_out, ">:encoding(utf8)", $temp_file) or die "$temp_file: $!";
my @lines = split(/\n/, $src);
foreach my $line (@lines){
    if ($line ne ""){
        print $fh_out "$lang_source: $line\n" or die "writing $temp_file: $!";
    }
}
close($fh_out);

my @sentences = `$Bin/sentence_split.sh < $temp_file`;
foreach my $s (@sentences){
    $s = decode('utf8', $s);
    chomp $s;
    $s =~ s/^$lang_source: //;
    $s =~ s/&/&amp;/sg;
    $s =~ s/</&lt;/sg;
    $s =~ s/>/&gt;/sg;
    $s =~ s/"/&quot;/sg;
}
# 文分割が失敗した場合
if (scalar(@sentences) == 0) {
    @sentences = @lines;
}

my $article_id = time;
my $resp = {};
$resp->{'articleId'} = $article_id;
$resp->{'sentences'} = \@sentences;
my $json_resp = to_json($resp);

$response .= "\n" . $json_resp;
print $response;

